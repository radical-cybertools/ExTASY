.. _examples:

************************
Running Generic Examples
************************

Multiple Simulations Single Analysis Application with SAL pattern
=================================================================

This example shows how to use the SAL pattern to execute 4 iterations of a simulation analysis loop with multiple simulation instances and a single analysis instance. We skip the ``pre_loop`` step in this example. Each ``simulation_step`` generates 16 new random ASCII files. One ASCII file in each of its instances. In the ``analysis_step``, the ASCII files from each of the simulation instances are analyzed and character count is performed on each of the files using one analysis instance. The output is downloaded to the user machine.


.. parsed-literal::
	
	[S]    [S]    [S]    [S]    [S]    [S]    [S]
 	 |      |      |      |      |      |      |
 	 \\-----------------------------------------/
	                      |
	                     [A]
	                      |
 	 /-----------------------------------------\\
	 |      |      |      |      |      |      |
	[S]    [S]    [S]    [S]    [S]    [S]    [S]
 	 |      |      |      |      |      |      |
 	 \\-----------------------------------------/
	                      |
         	             [A]
         	              .
         	              .


.. warning:: In order to run this example, you need access to a MongoDB server and set the ``RADICAL_PILOT_DBURL`` in your environment accordingly. The format is ``mongodb://hostname:port``. 

Run locally
-----------

* Step 1: View the example source :ref:`below <mssa>`. You can download the generic examples using the following:

.. code-block:: bash

	curl -k -O  https://raw.githubusercontent.com/radical-cybertools/ExTASY/extasy_0.2-devel/tarballs/generic.tar.gz
	tar xfz generic.tar.gz
	cd generic

.. note::

	The files in the above link are configured to run for the CECAM workshop. The source at the end of this page is generic and might require changes.

* Step 2: Run the ``multiple_simulations_single_analysis`` example with ``RADICAL_ENMD_VERBOSE`` set to ``REPORT`` if you want to see log messages about simulation progress:


If your shell is BASH,

.. code-block:: bash

	RADICAL_ENMD_VERBOSE=REPORT python multiple_simulations_single_analysis.py


If your shell is CSH,

.. code-block:: csh

	setenv RADICAL_ENMD_VERBOSE 'REPORT'
	python multiple_simulations_single_analysis.py

Once the script has finished running, you should see the character frequency files generated by the individual ensembles (cfreqs-1.dat) in the in the same directory you launched the script in. You should see as many such files as were the number of iterations. Each analysis stage generates the character frequency file for all the files generated in the simulation stage every iteration.

Run remotely
------------

By default, simulation and analysis steps run on one core your local machine:

.. parsed-literal::

	SingleClusterEnvironment(
    	resource="local.localhost",
    	cores=1,
    	walltime=30,
    	username=None,
    	project=None
	)

You can change the script to use a remote HPC cluster and increase the number of cores to see how this affects the runtime of the script as the individual simulations instances can run in parallel. For example, execution on xsede.stampede using 16 cores would require:

.. parsed-literal::

	SingleClusterEnvironment(
    	resource="xsede.stampede",
    	cores=16,
    	walltime=30,	#minutes
    	username=None,  # add your username here
    	project=None # add your allocation or project id here if required
	)


Example Script
--------------

.. _mssa:

:download:`Download multiple_simulations_single_analysis.py <../../examples/generic/multiple_simulations_single_analysis.py>`

.. literalinclude:: ../../examples/generic/multiple_simulations_single_analysis.py
	:language: python
	:linenos:

In line 55, a SingleClusterEnvironment (Execution context) is created targetted to reserve **1** core on **localhost** for a duration of **30 mins**. In line 64, an allocation request is made for the particular execution context.

In line 16, we define the pattern class to be the SAL pattern. We skip the definition of the ``pre_loop`` step since we do not require it for this example. In line 27, we define the kernel that needs to be executed during the simulation step (mkfile) as well as the arguments to the kernel. In line 41, we define the kernel that needs to be executed during the analysis step (ccount). In lines 38-39, we create a list of references to the output data created in each of the simulation instances, in order to stage it in during the analysis instance (line 43).

In line 68, we create an instance of this MSSA class to run 4 iterations of 16 simulation instances and 1 analysis instance. We run this pattern in the execution context in line 70 and once completed we deallocate the acquired resources (line 72).


Multiple Simulations Multiple Analysis Application with SAL pattern
===================================================================

This example shows how to use the SAL pattern to execute 4 iterations of a simulation analysis loop with multiple simulation instances and multiple analysis instance. We skip the ``pre_loop`` step in this example. Each ``simulation_step`` generates 16 new random ASCII files. One ASCII file in each of its instances. In the ``analysis_step``, the ASCII files from the simulation instances are analyzed and character count is performed. Each analysis instance uses the file generated by the corresponding simulation instance. This is possible since we use the same number of instances for simulation and analysis.The output is downloaded to the user machine.


.. parsed-literal::
	
	[S]    [S]    [S]    [S]    [S]    [S]    [S]    [S]
 	 |      |      |      |      |      |      |      |
	[A]    [A]    [A]    [A]    [A]    [A]    [A]    [A]
 	 |      |      |      |      |      |      |      |
	[S]    [S]    [S]    [S]    [S]    [S]    [S]    [S]
 	 |      |      |      |      |      |      |      |
	[A]    [A]    [A]    [A]    [A]    [A]    [A]    [A]


.. warning:: In order to run this example, you need access to a MongoDB server and set the ``RADICAL_PILOT_DBURL`` in your environment accordingly. The format is ``mongodb://hostname:port``. 

Run locally
-----------

* Step 1: View the example sources :ref:`below <msma>`. You can download the generic examples using the following (same link as above):

.. code-block:: bash

	curl -k -O  https://raw.githubusercontent.com/radical-cybertools/ExTASY/extasy_0.2-devel/tarballs/generic.tar.gz
	tar xfz generic.tar.gz
	cd generic

.. note::

	The files in the above link are configured to run for the CECAM workshop. The source at the end of this page is generic and might require changes.


* Step 2: Run the ``multiple_simulations_multiple_analysis`` example with ``RADICAL_ENMD_VERBOSE`` set to ``REPORT`` if you want to see log messages about simulation progress:

If your shell is BASH,

.. code-block:: bash

	RADICAL_ENMD_VERBOSE=REPORT python multiple_simulations_multiple_analysis.py

If your shell is CSH,

.. code-block:: csh

	setenv RADICAL_ENMD_VERBOSE 'REPORT' 
	python multiple_simulations_multiple_analysis.py

Once the script has finished running, you should see the character frequency files generated by the individual ensembles (cfreqs-1-1.dat) in the in the same directory you launched the script in. You should see as many such files as were the number of iterations times the number of ensembles (i.e. simulation/analysis width). Each analysis stage generates the character frequency file for each of the files generated in the simulation stage every iteration.

Run remotely
------------

By default, simulation and analysis steps run on one core your local machine:

.. parsed-literal::

	SingleClusterEnvironment(
    	resource="local.localhost",
    	cores=1,
    	walltime=30,
    	username=None,
    	project=None
	)

You can change the script to use a remote HPC cluster and increase the number of cores to see how this affects the runtime of the script as the individual simulations instances can run in parallel. For example, execution on xsede.stampede using 16 cores would require:

.. parsed-literal::

	SingleClusterEnvironment(
    	resource="xsede.stampede",
    	cores=16,
    	walltime=30,
    	username=None,  # add your username here
    	project=None # add your allocation or project id here if required
	)


Example Script
--------------

.. _msma:

:download:`Download multiple_simulations_multiple_analysis.py <../../examples/generic/multiple_simulations_multiple_analysis.py>`

.. literalinclude:: ../../examples/generic/multiple_simulations_multiple_analysis.py
	:language: python
	:linenos:

In line 51, a SingleClusterEnvironment (Execution context) is created targetted to reserve **1** core on **localhost** for a duration of **30 mins**. In line 60, an allocation request is made for the particular execution context.

In line 16, we define the pattern class to be the SAL pattern. We skip the definition of the ``pre_loop`` step since we do not require it for this example. In line 27, we define the kernel that needs to be executed during the simulation step (mkfile) as well as the arguments to the kernel. In line 37, we define the kernel that needs to be executed during the analysis step (ccount). In lines 39, we refer to the output data created in the previous simulation step with the same instance number as that of the current analysis instance. 

In line 63, we create an instance of this MSSA class to run 4 iterations of 16 simulation instances and 1 analysis instance. We run this pattern in the execution context in line 65 and once completed we deallocate the acquired resources (line 67).
